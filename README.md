# 1. TDD HomeWork 

## 요구사항 정리
### 기능 구현 
*  `GET` `/point/{id}` 포인트 조회 API
*  `PATCH` `/point/{id}/use`  포인트 사용 API 
*  `PATCH` `/point/{id}/charge` 포인트 충전 API
*  `GET` `/point/{id}/histories` 포인트 사용 내역 조회 API

### TDD 과제 
[ DEFAULT ]<br>
- `/point` 패키지 (디렉토리) 내에 `PointService` 기본 기능 작성
- `/database` 패키지의 구현체는 수정하지 않고, 이를 활용해 기능을 구현
- 각 기능에 대한 단위 테스트 작성

[ STEP 1 ]<br>
- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
  - 추가 정책 사항
    - point 0원 일 때 사용시 잔고 부족 에러 
    - 최대 충전 금액 => 100,000 원
    - 최대 잔고 1,000,000 Point => 추가 충전 불가 에러 
    - point 미 생성시 에러 => 충전 / 사용시 에러
    - ID 음수 / 0 일 떄 에러
    - amount 음수 / 0 일때 에러
    
- 동시에 여러 요청이 들어오더라도 순서대로 (혹은 한번에 하나의 요청씩만) 제어될 수 있도록 리팩토링
- 동시성 제어에 대한 통합 테스트 작성

[ STEP 2 ]<br>
- 동시성 제어 방식에 대한 분석 및 보고서 작성 ( README.md )


## 동시성 제어 방식에 대한 분석 및 보고서 작성
### 제한
* Code 내에서 적용 해야함 ( DB 등 다른 Third Party 동시성 제어 x )


### 동시성 제어 방식에 대한 종류 

* `Synchronized`
* `Volatile`
* `Atomic`


### Synchronized

쓰레드를 제어할 때 해당 문법을 이용하면 `Synchronized` 선언된 변수명에 접근할 떄 Lock 을 하게 되어  
하나의 `Thread` 만이 해당 변수에 접근할 수 있어서 동시성 제어가 가능하다 

* 장점: 사용하기 간편 하다
* 단점:
  * 대신 lock 을 걸떄 블락 전체에 걸기 때문에 쓰레드가 많아 질 수록 대기가 많이 일어난다. 
  * 특정 사항일 떄만 Lock 을 걸기 힘들다.


### Volatile
JVM 에서 실행되고 있는 CPU Cache 메모리를 항상 최신 값으로 Update 해주는 기능이다 

* 장점: 
  * 변수 키워드 앞에 붙이기만 하면 사용 가능
* 단점: 
  * 원자성이 보장되지 않은 경우 동시성 문제는 동일하게 발생한다.

### Atomic 클래스
CAS(Compare-and-swap) 알고리즘을 이용한 클래스 모음  
volatile 키워드를 이용하면서 현재 스레드에 저장된 값과 메인 메모리에 저장된 값을 비교한다.  
일치하는 경우 새로운 값으로 교체(thread-safe 한 상태이므로 로직 수행)  
일치하지 않는 경우 실패 후 재시도(thread-safe 하지 않은 상태였으므로 재시도)


* 장점: 
  * NonBlocking 임에도 속도가 빠르며 동시성 문제해결을 위해 만든 클래스인 만큼 어느정도 동시성 문제가 해결된다
* 단점: 
  * 추가 클래스들을 익혀야한다.



### 결과적으로 JAVA 에서 동시성 문제를 해결하려면 Atomic 클래스를 이용하는 것이 좋다.


